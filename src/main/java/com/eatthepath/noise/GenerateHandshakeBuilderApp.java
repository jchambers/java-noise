package com.eatthepath.noise;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

class GenerateHandshakeBuilderApp {

  private static final String[] HANDSHAKE_PATTERNS = new String[] {
      "N", "K", "X", "NN", "KN", "NK", "KK", "NX", "KX", "XN", "IN", "XK", "IK", "XX", "IX", "NK1", "NX1", "X1N", "X1K",
      "XK1", "X1K1", "X1X", "XX1", "X1X1", "K1N", "K1K", "KK1", "K1K1", "K1X", "KX1", "K1X1", "I1N", "I1K", "IK1",
      "I1K1", "I1X", "IX1", "I1X1", "Npsk0", "Kpsk0", "Xpsk1", "NNpsk0", "NNpsk2", "NKpsk0", "NKpsk2", "NXpsk2",
      "XNpsk3", "XKpsk3", "XXpsk3", "KNpsk0", "KNpsk2", "KKpsk0", "KKpsk2", "KXpsk2", "INpsk1", "INpsk2", "IKpsk1",
      "IKpsk2", "IXpsk2"
  };

  private static final String INITIALIZER_TEMPLATE = """
      public static NoiseHandshakeBuilder for%METHOD_SAFE_PATTERN_NAME%%METHOD_SAFE_ROLE_NAME%(%ARGUMENT_LIST%) {
        try {
          return new NoiseHandshakeBuilder(NoiseHandshake.Role.%ROLE_ENUM_KEY%,
              HandshakePattern.getInstance("%PATTERN_NAME%"),
              %LOCAL_STATIC_KEY_PAIR_ARGUMENT%,
              %REMOTE_STATIC_PUBLIC_KEY_ARGUMENT%,
              %PRE_SHARED_KEY_ARGUMENT%);
        } catch (final NoSuchPatternException e) {
          throw new AssertionError("Statically-generated handshake pattern not found", e);
        }
      }
      """;

  private static final String HANDSHAKE_BUILDER_TEMPLATE_FILE = "NoiseHandshakeBuilder.java.template";

  private static final String INITIALIZER_TEMPLATE_PLACEHOLDER = "// ----- AUTOGENERATED INITIALIZERS HERE -----";

  public static void main(final String... args) throws IOException {
    final String renderedInitializers = Arrays.stream(HANDSHAKE_PATTERNS)
        .map(name -> {
          try {
            return HandshakePattern.getInstance(name);
          } catch (final NoSuchPatternException e) {
            throw new AssertionError("All known patterns must exist", e);
          }
        })
        .map(handshakePattern -> Arrays.stream(NoiseHandshake.Role.values())
            .map(role -> renderTemplate(buildTemplateModel(handshakePattern, role))
                .lines()
                .map(line -> "  " + line)
                .collect(Collectors.joining("\n")))
            .collect(Collectors.joining("\n\n")))
        .collect(Collectors.joining("\n\n"));

    try (final InputStream templateInputStream = GenerateHandshakeBuilderApp.class.getResourceAsStream(HANDSHAKE_BUILDER_TEMPLATE_FILE)) {
      if (templateInputStream == null) {
        throw new IOException("Could not read template file");
      }

      final String templateString = new String(templateInputStream.readAllBytes(), StandardCharsets.UTF_8);

      System.out.println(templateString.replace(INITIALIZER_TEMPLATE_PLACEHOLDER, renderedInitializers));
    }
  }

  private static Map<String, String> buildTemplateModel(final HandshakePattern handshakePattern, final NoiseHandshake.Role role) {
    final String methodSafeRoleName = switch (role) {
      case INITIATOR -> "Initiator";
      case RESPONDER -> "Responder";
    };

    final String methodSafePatternName = HandshakePattern.getFundamentalPatternName(handshakePattern.name()) +
        HandshakePattern.getModifiers(handshakePattern.name()).stream()
            .map(modifier -> {
              final char firstChar = Character.toUpperCase(modifier.charAt(0));
              return firstChar + modifier.substring(1);
            })
            .collect(Collectors.joining());

    final List<String> arguments = new ArrayList<>(3);

    final String localStaticKeyPairArgument;

    if (handshakePattern.requiresLocalStaticKeyPair(role)) {
      arguments.add("final KeyPair localStaticKeyPair");
      localStaticKeyPairArgument = "localStaticKeyPair";
    } else {
      localStaticKeyPairArgument = "null";
    }

    final String remoteStaticPublicKeyArgument;

    if (handshakePattern.requiresRemoteStaticPublicKey(role)) {
      arguments.add("final PublicKey remoteStaticPublicKey");
      remoteStaticPublicKeyArgument = "remoteStaticPublicKey";
    } else {
      remoteStaticPublicKeyArgument = "null";
    }

    final String preSharedKeyArgument;

    if (handshakePattern.getRequiredPreSharedKeyCount() > 0) {
      arguments.add("final byte[] preSharedKey");
      preSharedKeyArgument = "preSharedKey";
    } else {
      preSharedKeyArgument = "null";
    }

    return Map.of(
        "%METHOD_SAFE_PATTERN_NAME%", methodSafePatternName,
        "%METHOD_SAFE_ROLE_NAME%", methodSafeRoleName,
        "%ROLE_ENUM_KEY%", role.name(),
        "%PATTERN_NAME%", handshakePattern.name(),
        "%ARGUMENT_LIST%", String.join(", ", arguments),
        "%LOCAL_STATIC_KEY_PAIR_ARGUMENT%", localStaticKeyPairArgument,
        "%REMOTE_STATIC_PUBLIC_KEY_ARGUMENT%", remoteStaticPublicKeyArgument,
        "%PRE_SHARED_KEY_ARGUMENT%", preSharedKeyArgument);
  }

  private static String renderTemplate(final Map<String, String> model) {
    String renderedTemplate = INITIALIZER_TEMPLATE;

    for (final Map.Entry<String, String> entry : model.entrySet()) {
      renderedTemplate = renderedTemplate.replace(entry.getKey(), entry.getValue());
    }

    return renderedTemplate;
  }
}
