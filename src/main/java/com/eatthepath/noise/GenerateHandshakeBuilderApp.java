package com.eatthepath.noise;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.stream.Collectors;

class GenerateHandshakeBuilderApp {

  private static final String[] HANDSHAKE_PATTERNS = new String[] {
      "N", "K", "X", "NN", "KN", "NK", "KK", "NX", "KX", "XN", "IN", "XK", "IK", "XX", "IX", "NK1", "NX1", "X1N", "X1K",
      "XK1", "X1K1", "X1X", "XX1", "X1X1", "K1N", "K1K", "KK1", "K1K1", "K1X", "KX1", "K1X1", "I1N", "I1K", "IK1",
      "I1K1", "I1X", "IX1", "I1X1", "Npsk0", "Kpsk0", "Xpsk1", "NNpsk0", "NNpsk2", "NKpsk0", "NKpsk2", "NXpsk2",
      "XNpsk3", "XKpsk3", "XXpsk3", "KNpsk0", "KNpsk2", "KKpsk0", "KKpsk2", "KXpsk2", "INpsk1", "INpsk2", "IKpsk1",
      "IKpsk2", "IXpsk2"
  };

  private static final String INITIALIZER_TEMPLATE = """
      /**
       * Constructs a new Noise handshake builder for the %SENTENCE_ROLE_NAME% in %PATTERN_INDEFINITE_ARTICLE%
       * %PATTERN_NAME% handshake.
       *
       * %LOCAL_STATIC_KEY_PAIR_PARAM_TAG%
       * %REMOTE_STATIC_PUBLIC_KEY_PARAM_TAG%
       * %PRE_SHARED_KEY_PARAM_TAG%
       *
       * @return a new Noise handshake builder
       *
       * %THROWS_TAG%
       */
      public static NoiseHandshakeBuilder for%METHOD_SAFE_PATTERN_NAME%%METHOD_SAFE_ROLE_NAME%(%ARGUMENT_LIST%) {
        try {
          return new NoiseHandshakeBuilder(NoiseHandshake.Role.%ROLE_ENUM_KEY%,
              HandshakePattern.getInstance("%PATTERN_NAME%"),
              %LOCAL_STATIC_KEY_PAIR_ARGUMENT%,
              %REMOTE_STATIC_PUBLIC_KEY_ARGUMENT%,
              %PRE_SHARED_KEY_ARGUMENT%);
        } catch (final NoSuchPatternException e) {
          throw new AssertionError("Statically-generated handshake pattern not found", e);
        }
      }
      """;

  private static final String HANDSHAKE_BUILDER_TEMPLATE_FILE = "NoiseHandshakeBuilder.java.template";

  private static final String INITIALIZER_TEMPLATE_PLACEHOLDER = "// ----- AUTOGENERATED INITIALIZERS HERE -----";

  public static void main(final String... args) throws IOException {
    final String renderedInitializers = Arrays.stream(HANDSHAKE_PATTERNS)
        .map(name -> {
          try {
            return HandshakePattern.getInstance(name);
          } catch (final NoSuchPatternException e) {
            throw new AssertionError("All known patterns must exist", e);
          }
        })
        .map(handshakePattern -> Arrays.stream(NoiseHandshake.Role.values())
            .map(role -> renderTemplate(buildTemplateModel(handshakePattern, role))
                .lines()
                .map(line -> "  " + line)
                .collect(Collectors.joining("\n")))
            .collect(Collectors.joining("\n\n")))
        .collect(Collectors.joining("\n\n"));

    try (final InputStream templateInputStream = GenerateHandshakeBuilderApp.class.getResourceAsStream(HANDSHAKE_BUILDER_TEMPLATE_FILE)) {
      if (templateInputStream == null) {
        throw new IOException("Could not read template file");
      }

      final String templateString = new String(templateInputStream.readAllBytes(), StandardCharsets.UTF_8);

      System.out.println(templateString.replace(INITIALIZER_TEMPLATE_PLACEHOLDER, renderedInitializers));
    }
  }

  private static Map<String, String> buildTemplateModel(final HandshakePattern handshakePattern, final NoiseHandshake.Role role) {
    final String methodSafeRoleName = switch (role) {
      case INITIATOR -> "Initiator";
      case RESPONDER -> "Responder";
    };

    final String methodSafePatternName = HandshakePattern.getFundamentalPatternName(handshakePattern.getName()) +
        HandshakePattern.getModifiers(handshakePattern.getName()).stream()
            .map(modifier -> {
              final char firstChar = Character.toUpperCase(modifier.charAt(0));
              return firstChar + modifier.substring(1);
            })
            .collect(Collectors.joining());

    final List<String> arguments = new ArrayList<>(3);

    final String localStaticKeyPairArgument;
    final String localStaticKeyPairParamTag;

    if (handshakePattern.requiresLocalStaticKeyPair(role)) {
      arguments.add("final KeyPair localStaticKeyPair");
      localStaticKeyPairArgument = "Objects.requireNonNull(localStaticKeyPair, \"Local static key pair must not be null\")";
      localStaticKeyPairParamTag = "@param localStaticKeyPair the local static key pair for this handshake; must not be {@code null}";
    } else {
      localStaticKeyPairArgument = "null";
      localStaticKeyPairParamTag = "";
    }

    final String remoteStaticPublicKeyArgument;
    final String remoteStaticPublicKeyParamTag;

    if (handshakePattern.requiresRemoteStaticPublicKey(role)) {
      arguments.add("final PublicKey remoteStaticPublicKey");
      remoteStaticPublicKeyArgument = "Objects.requireNonNull(remoteStaticPublicKey, \"Remote static public key must not be null\")";
      remoteStaticPublicKeyParamTag = "@param remoteStaticPublicKey the remote static public key for this handshake; must not be {@code null}";
    } else {
      remoteStaticPublicKeyArgument = "null";
      remoteStaticPublicKeyParamTag = "";
    }

    final String preSharedKeyArgument;
    final String preSharedKeyParamTag;

    if (handshakePattern.getRequiredPreSharedKeyCount() > 0) {
      arguments.add("final byte[] preSharedKey");
      preSharedKeyArgument = "Objects.requireNonNull(preSharedKey, \"Pre-shared key must not be null\")";
      preSharedKeyParamTag = "@param preSharedKey the pre-shared key for this handshake; must not be {@code null}";
    } else {
      preSharedKeyArgument = "null";
      preSharedKeyParamTag = "";
    }

    final String throwsTag;
    {
      final StringBuilder throwsTagBuilder = new StringBuilder();

      if (!arguments.isEmpty()) {
        throwsTagBuilder.append("@throws NullPointerException if any required key {@code null}");
      }

      if (handshakePattern.getRequiredPreSharedKeyCount() > 0) {
        throwsTagBuilder.append("\n  * @throws IllegalArgumentException if the given pre-shared key is not exactly 32 bytes long");
      }

      throwsTag = throwsTagBuilder.toString();
    }

    final Map<String, String> templateModel = new HashMap<>();

    templateModel.put("%METHOD_SAFE_PATTERN_NAME%", methodSafePatternName);
    templateModel.put("%METHOD_SAFE_ROLE_NAME%", methodSafeRoleName);
    templateModel.put("%ROLE_ENUM_KEY%", role.name());
    templateModel.put("%PATTERN_NAME%", handshakePattern.getName());
    templateModel.put("%ARGUMENT_LIST%", String.join(", ", arguments));
    templateModel.put("%LOCAL_STATIC_KEY_PAIR_ARGUMENT%", localStaticKeyPairArgument);
    templateModel.put("%REMOTE_STATIC_PUBLIC_KEY_ARGUMENT%", remoteStaticPublicKeyArgument);
    templateModel.put("%PRE_SHARED_KEY_ARGUMENT%", preSharedKeyArgument);
    templateModel.put("%SENTENCE_ROLE_NAME%", role.name().toLowerCase());
    templateModel.put("%PATTERN_INDEFINITE_ARTICLE%", handshakePattern.getName().charAt(0) == 'K' ? "a" : "an");
    templateModel.put("%LOCAL_STATIC_KEY_PAIR_PARAM_TAG%", localStaticKeyPairParamTag);
    templateModel.put("%REMOTE_STATIC_PUBLIC_KEY_PARAM_TAG%", remoteStaticPublicKeyParamTag);
    templateModel.put("%PRE_SHARED_KEY_PARAM_TAG%", preSharedKeyParamTag);
    templateModel.put("%THROWS_TAG%", throwsTag);

    return templateModel;
  }

  private static String renderTemplate(final Map<String, String> model) {
    String renderedTemplate = INITIALIZER_TEMPLATE;

    for (final Map.Entry<String, String> entry : model.entrySet()) {
      renderedTemplate = renderedTemplate.replace(entry.getKey(), entry.getValue());
    }

    return renderedTemplate;
  }
}
