<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (21) on Sun Mar 03 12:08:44 EST 2024 -->
<title>Overview (java-noise 0.0.0-SNAPSHOT API)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2024-03-03">
<meta name="description" content="package index">
<meta name="generator" content="javadoc/PackageIndexWriter">
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="script-dir/jquery-ui.min.css" title="Style">
<script type="text/javascript" src="script.js"></script>
<script type="text/javascript" src="script-dir/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="script-dir/jquery-ui.min.js"></script>
</head>
<body class="package-index-page">
<script type="text/javascript">var pathtoroot = "./";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li class="nav-bar-cell1-rev">Overview</li>
<li>Package</li>
<li>Class</li>
<li>Use</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html#overview">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list"></div>
<div class="nav-list-search"><a href="search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<div class="header">
<h1 class="title">java-noise 0.0.0-SNAPSHOT API</h1>
</div>
<div class="block"><p>java-noise is a Java implementation of the <a href="https://noiseprotocol.org/">Noise Protocol Framework</a>, which describes itself as:</p>

<blockquote>…a framework for building crypto protocols. Noise protocols support mutual and optional authentication, identity hiding, forward secrecy, zero round-trip encryption, and other advanced features.</blockquote>

<p>java-noise supports all handshake patterns, handshake pattern modifiers, and cryptographic algorithms enumerated in revision 34 of the <a href="https://noiseprotocol.org/noise.html">Noise Protocol Framework specification</a>. Some cryptographic algorithms depend on the presence of a security provider that provides an implementation of the named algorithm. In particular:</p>

<ul>
    <li>The "25519" key agreement algorithm requires that the JVM have a security provider that supports the "X25519" <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/javax/crypto/KeyAgreement.html" title="class or interface in javax.crypto" class="external-link"><code>KeyAgreement</code></a> and <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/security/KeyPairGenerator.html" title="class or interface in java.security" class="external-link"><code>KeyPairGenerator</code></a> algorithms</li>
    <li>The "448" key agreement algorithm requires that the JVM have a security provider that supports the "X448" <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/javax/crypto/KeyAgreement.html" title="class or interface in javax.crypto" class="external-link"><code>KeyAgreement</code></a> and <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/security/KeyPairGenerator.html" title="class or interface in java.security" class="external-link"><code>KeyPairGenerator</code></a> algorithms</li>
    <li>The "ChaChaPoly" cipher algorithm requires that the JVM have a security provider that supports the "ChaCha20-Poly1305" <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/javax/crypto/Cipher.html" title="class or interface in javax.crypto" class="external-link"><code>Cipher</code></a> algorithm</li>
    <li>The "SHA512" hash algorithm requires that the JVM have a security provider that supports the "SHA-512" <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/security/MessageDigest.html" title="class or interface in java.security" class="external-link"><code>MessageDigest</code></a> algorithm and the "HmacSHA512" <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/javax/crypto/Mac.html" title="class or interface in javax.crypto" class="external-link"><code>Mac</code></a> algorithm</li>
</ul>

<p>All other algorithms named in the Noise Protocol Framework specification are supported unconditionally.</p>

<h1 id="handshakes-heading">Handshakes</h1>

<p>A Noise protocol begins with a handshake in which two parties (an initiator and a responder) exchange handshake messages that contain key material and optional payloads to negotiate a shared secret key and establish an ongoing session for Noise transport messages. Noise handshakes are described by <a href="https://noiseprotocol.org/noise.html#handshake-patterns">"handshake patterns"</a>, which prescribe the handshake messages exchanged between the initiator and responder. In java-noise, Noise handshakes are managed by <a href="com/eatthepath/noise/NoiseHandshake.html" title="class in com.eatthepath.noise"><code>NoiseHandshake</code></a> instances.</p>

<p><code>NoiseHandshake</code> instances can be constructed using either a <a href="com/eatthepath/noise/NoiseHandshakeBuilder.html" title="class in com.eatthepath.noise"><code>NoiseHandshakeBuilder</code></a>, which provides static initializers for common Noise handshake patterns, or a <a href="com/eatthepath/noise/NamedProtocolHandshakeBuilder.html" title="class in com.eatthepath.noise"><code>NamedProtocolHandshakeBuilder</code></a>, which allows for arbitrary handshake pattern names, but only offers runtime checks (as opposed to compile-time checks) that appropriate key material has been provided before building a <code>NoiseHandshake</code> instance.</p>

<h2 id="interactive-patterns-heading">Interactive patterns</h2>

<p>In the most common case, Noise handshakes implement a interactive pattern in which both parties will send and receive messages to one another once the handshake is complete. As an example, the NN interactive handshake pattern is defined as:</p>

<pre>NN:
  -&gt; e
  &lt;- e, ee</pre>

<p>The parties in an NN handshake exchange messages until all required messages have been exchanged, then the handshake instances yield interactive transport instances:</p>

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">final NoiseHandshake initiatorHandshake = NoiseHandshakeBuilder.forNNInitiator()
    .setComponentsFromProtocolName("Noise_NN_25519_AESGCM_SHA256")
    .build();

final NoiseHandshake responderHandshake = NoiseHandshakeBuilder.forNNResponder()
    .setComponentsFromProtocolName("Noise_NN_25519_AESGCM_SHA256")
    .build();

// -&gt; e (with an empty payload)
final byte[] initiatorEMessage = initiatorHandshake.writeMessage((byte[]) null);
responderHandshake.readMessage(initiatorEMessage);

// &lt;- e, ee (with an empty payload)
final byte[] responderEEeMessage = responderHandshake.writeMessage((byte[]) null);
initiatorHandshake.readMessage(responderEEeMessage);

assert initiatorHandshake.isDone();
assert responderHandshake.isDone();

final NoiseTransport initiatorTransport = initiatorHandshake.toTransport();
final NoiseTransport responderTransport = responderHandshake.toTransport();
</code></pre>
</div>


<h2 id="one-way-patterns-heading">One-way patterns</h2>

<p>Noise handshakes may also use one-way patterns. As the Noise Protocol Framework specification notes:</p>

<blockquote>These patterns could be used to encrypt files, database records, or other non-interactive data streams.</blockquote>

<p>One-way handshakes exchange handshake messages in the same way as interactive handshakes, but instead of producing interactive <a href="com/eatthepath/noise/NoiseTransport.html" title="interface in com.eatthepath.noise"><code>NoiseTransport</code></a> instances, one-way handshakes produce a one-way <a href="com/eatthepath/noise/NoiseTransportWriter.html" title="interface in com.eatthepath.noise"><code>NoiseTransportWriter</code></a> for initiators or <a href="com/eatthepath/noise/NoiseTransportReader.html" title="interface in com.eatthepath.noise"><code>NoiseTransportReader</code></a> for responders. As an example, the N handshake pattern is defined as:</p>

<pre>N:
  &lt;- s
  ...
  -&gt; e, es</pre>

<p>The parties in an N handshake exchange messages as usual, then the handshake instances yield one-way transport instances:</p>

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">final NoiseHandshake initiatorHandshake = NoiseHandshakeBuilder.forNInitiator(responderStaticPublicKey)
    .setComponentsFromProtocolName("Noise_N_25519_AESGCM_SHA256")
    .build();

final NoiseHandshake responderHandshake = NoiseHandshakeBuilder.forNResponder(responderStaticKeyPair)
    .setComponentsFromProtocolName("Noise_N_25519_AESGCM_SHA256")
    .build();

// -&gt; e, es (with an empty payload)
final byte[] initiatorEphemeralKeyMessage = initiatorHandshake.writeMessage((byte[]) null);
responderHandshake.readMessage(initiatorEphemeralKeyMessage);

assert initiatorHandshake.isDone();
assert responderHandshake.isDone();

final NoiseTransportWriter transportWriter = initiatorHandshake.toTransportWriter();
final NoiseTransportReader transportReader = responderHandshake.toTransportReader();
</code></pre>
</div>


<h2 id="fallback-patterns-heading">Fallback patterns</h2>

<p>Noise handshakes can "fall back" to another pattern to handle certain kinds of errors. As an example, the<a href="https://noiseprotocol.org/noise.html#noise-pipes">Noise Pipes</a> compound protocol expects that initiators will usually have the responder's static public key available from a previous "full" (XX) handshake, and can use an abbreviated (IK) handshake pattern with that static key set via a pre-handshake message. If the responder can't decrypt a message from the initiator, though, it might conclude that the initiator has a stale copy of its public key and can fall back to a "full" (XXfallback) handshake.</p>

<p>The IK handshake pattern is defined as:</p>

<pre>IK:
  &lt;- s
  ...
  -&gt; e, es, s, ss
  &lt;- e, ee, se</pre>

<p>…and the XXfallback pattern is defined as:</p>

<pre>XXfallback:
  -&gt; e
  ...
  &lt;- e, ee, s, es
  -&gt; s, se</pre>

<p>As an example, consider a scenario where the initiator of an IK handshake has a "stale" static key for the responder:</p>

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">final NoiseHandshake ikInitiatorHandshake =
    NoiseHandshakeBuilder.forIKInitiator(initiatorStaticKeyPair, staleRemoteStaticPublicKey)
        .setComponentsFromProtocolName("Noise_IK_25519_AESGCM_SHA256")
        .build();

final NoiseHandshake ikResponderHandshake =
    NoiseHandshakeBuilder.forIKResponder(currentResponderStaticKeyPair)
        .setComponentsFromProtocolName("Noise_IK_25519_AESGCM_SHA256")
        .build();
</code></pre>
</div>


<p>The initiator sends its first message to the responder, which won't be able to decrypt the message due to the static key disagreement:</p>

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">// -&gt; e, es, s, ss (with an empty payload)
final byte[] initiatorStaticKeyMessage = ikInitiatorHandshake.writeMessage((byte[]) null);

// Throws an AEADBadTagException because the initiator has a stale static key for the responder
ikResponderHandshake.readMessage(initiatorStaticKeyMessage);
</code></pre>
</div>


<p>Rather than simply failing the handshake (assuming both the initiator and responder are expecting that a fallback may happen), the responder can fall back to the XXfallback pattern, reusing the ephemeral key it already received from the initiator as a pre-handshake message, and write a message to continue the XXfallback pattern:</p>

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">final NoiseHandshake xxFallbackResponderHandshake =
    ikResponderHandshake.fallbackTo("XXfallback");

// &lt;- e, ee, s, es (with an empty payload)
final byte[] responderStaticKeyMessage = xxFallbackResponderHandshake.writeMessage((byte[]) null);
</code></pre>
</div>


<p>The initiator will fail to decrypt the message from the responder:</p>

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">// Throws an AEADBadTagException
ikInitiatorHandshake.readMessage(responderStaticKeyMessage);
</code></pre>
</div>


<p>Like the responder, the initiator can take the decryption failure as a cue to fall back to the XXfallback pattern, then read the message and finish the handshake:</p>

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">final NoiseHandshake xxFallbackInitiatorHandshake =
    ikInitiatorHandshake.fallbackTo("XXfallback");

xxFallbackInitiatorHandshake.readMessage(responderStaticKeyMessage);

final byte[] initiatorFallbackStaticKeyMessage =
    xxFallbackInitiatorHandshake.writeMessage((byte[]) null);

xxFallbackResponderHandshake.readMessage(initiatorFallbackStaticKeyMessage);

assert xxFallbackInitiatorHandshake.isDone();
assert xxFallbackResponderHandshake.isDone();
</code></pre>
</div>


<p>Once the handshake is finished, the transition to the transport phase of the protocol continues as usual.</p>

<h1 id="transports-heading">Transports</h1>

<p>Once the handshake phase of a Noise protocol has finished, <code>NoiseHandshake</code> instances may be transformed or "split" (in the terminology of the Noise Protocol Framework specification) into Noise transport objects. Depending on the nature of the handshake and the role of the party in the handshake, a <code>NoiseHandshake</code> instance may be transformed into exactly one of:</p>

<ul>
    <li>A <a href="com/eatthepath/noise/NoiseTransportWriter.html" title="interface in com.eatthepath.noise"><code>NoiseTransportWriter</code></a> if the handshake is a one-way handshake for the handshake initiator</li>
    <li>A <a href="com/eatthepath/noise/NoiseTransportReader.html" title="interface in com.eatthepath.noise"><code>NoiseTransportReader</code></a> if the handshake is a one-way handshake for the handshake responder</li>
    <li>A <a href="com/eatthepath/noise/NoiseTransport.html" title="interface in com.eatthepath.noise"><code>NoiseTransport</code></a> if the handshake is interactive</li>
</ul>

<p>Once a handshake has been split, a Noise transport instance can be used to exchange transport messages as needed. Note that unlike handshake messages, transport messages contain only payload ciphertexts (i.e. they do not contain key material, and their content is always encrypted). As an example starting from a finished interactive handshake:</p>

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">final NoiseTransport initiatorTransport = initiatorHandshake.toTransport();
final NoiseTransport responderTransport = responderHandshake.toTransport();

final byte[] originalPlaintextBytes = "Hello, Bob!".getBytes(StandardCharsets.UTF_8);

final byte[] aliceToBobCiphertext =
    initiatorTransport.writeMessage(originalPlaintextBytes);

assert !Arrays.equals(aliceToBobCiphertext, originalPlaintextBytes);

final byte[] aliceToBobPlaintext = responderTransport.readMessage(aliceToBobCiphertext);

assert Arrays.equals(aliceToBobPlaintext, originalPlaintextBytes);
</code></pre>
</div>
</div>
<div id="all-packages-table">
<div class="caption"><span>Packages</span></div>
<div class="summary-table two-column-summary">
<div class="table-header col-first">Package</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color all-packages-table all-packages-table-tab1"><a href="com/eatthepath/noise/package-summary.html">com.eatthepath.noise</a></div>
<div class="col-last even-row-color all-packages-table all-packages-table-tab1">
<div class="block">Provides classes and interfaces for performing handshakes and exchanging messages via a Noise protocol.</div>
</div>
<div class="col-first odd-row-color all-packages-table all-packages-table-tab1"><a href="com/eatthepath/noise/component/package-summary.html">com.eatthepath.noise.component</a></div>
<div class="col-last odd-row-color all-packages-table all-packages-table-tab1">
<div class="block">Provides interfaces and concrete implementations of the cryptographic components of a Noise protocol (key agreement
 algorithms, ciphers, and hash algorithms).</div>
</div>
</div>
</div>
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small>Copyright &#169; 2024. All rights reserved.</small></p>
</footer>
</div>
</div>
</body>
</html>
